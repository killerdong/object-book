# 1장 객체, 설계

## 실무와 이론 중에서는 무엇이 먼저일 것인가?

이론이 정립할 수 없는 초기에는 실무가 먼저 급속도로 발전한다(로버트 I 글래스의 이론). 그래서 이렇게 발전된 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선의 방법이다. 이 내용을 소프트웨어에 적용해보면 소프트웨어의 경우 설계와 유지보수 분야에서 이 내용이 적용된 분야라고 할 수 있다. 소프트웨어 설계의 경우 실무에서는 다양한 기법과 도구를 초기부터 성공적으로 적용하고 발전 시켜 왔지만 설계 관련 이론은 1970년대가 돼서야 비로소 세상에 모습이 드러냈다. 그리고 대부분의 이론은 실무를 기반으로 실무에서 반복적으로 적용한 기법들에 대한 이론화한 것들이다. 그렇기에 설계를 설명할 때 가장 유용한 도구는 이론으로 치장된 개념과 용어가 아니라 코드 그 자체다. 프로그램을 통해 개념과 이론을 배우는 것이 개념과 이론을 통해 프로그램을 배우는 것보다 더 훌륭한 학습 방법이라고 생각한다.

## 티켓 판매 애플리케이션

### 1차 코딩

키밋로그 참고

### 문제점이 무엇인가?

#### 모듈이란?

* 크기와 상관 없이 클래시나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미
* 모듈의 3가지 목적
   1. 실행 중에 제대로 동작하는 것
   2. 변경을 위해 존재
   3. 코드를 읽는 사람과 의사소통하는 것

#### 예상을 빗나가는 코드

```javascript
enter(audience: Audience): void {
    if (audience.getBag().hasInvitation()) {
        const ticket:Ticket = this.ticketSeller.getTicketOffice().getTicket();
        audience.getBag().setTicket(ticket);
    } else {
        const ticket:Ticket = this.ticketSeller.getTicketOffice().getTicket();
        audience.getBag().minusAmount(ticket.getFee());
        this.ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
        audience.getBag().setTicket(ticket);
    }
}

```
위 코드는 Theater.ts 소스 내에 있던 enter 함수의 내용이다. 이 함수에는 몇 가지의 문제점이 있다.

1. 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다. 소극장에서 관람객의 지갑을 강제로 꺼내고 거기에 초대권이 있는지 확인하는 등의 일을 하고, 매표소의 티켓과 돈을 마음대로 관리한다. 상식적으로 생각하보면 돈을 지갑에서 꺼낼 수 있는 주체는 지갑의 주인인 관람객이어야 하고, 매표소의 티켓과 돈을 관리할 수 있는 사람은 판매원이어야 한다. 이렇게 상식적으로 벗어나는 코드는 읽는 사람과 제대로된 소통을 할 수 없게 된다.
2. 이 코드를 이해하기 위해서는 여러 가지 세부적인  내용들을 한꺼번에 기억하고 있어야 한다는 점이다. enter 함수를 이해하기 위해서는 관람객이 가방을 가지고 있어야 한다는 정보를 알아야 하고, 가방에는 돈과 티켓이 들어 있어야 한다는 정보, 판매원이 매표소에서 티켓을 판매하고 있다는 정보 등을 알고 있어야 한다. 이 것은 코드를 읽는 사람에게 너무 큰 부담이 된다.
3. 변경에 취약하다. 이 코드는 가정을 하고 있는 내용이 너무 많다. 관람객이 현금과 초대장을 보관하기 위해서 항상 가방을 들고 다닌다는 점, 판매원은 매표소에서만 티켓을 판매한다는 점등등. 만약에 이런 정보가 변경되어야 한다면 너무 많은 부분의 소스를 변경해야 하는 문제점이 발생한다. 이런 내용을 극장과 관람객 사이의 의존성이 있다라고 이야기를 한다. 여기서 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다. 그리고 이론 의존성이 과한 경우를 결합도가 높다고 말한다.

> 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.

## 자율적인 객체 만들기





